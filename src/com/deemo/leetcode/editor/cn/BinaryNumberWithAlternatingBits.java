//////////////////////给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。 
//////////////////////
////////////////////// 
//////////////////////
////////////////////// 示例 1： 
//////////////////////
////////////////////// 
//////////////////////输入：n = 5
//////////////////////输出：true
//////////////////////解释：5 的二进制表示是：101
////////////////////// 
//////////////////////
////////////////////// 示例 2： 
//////////////////////
////////////////////// 
//////////////////////输入：n = 7
//////////////////////输出：false
//////////////////////解释：7 的二进制表示是：111. 
//////////////////////
////////////////////// 示例 3： 
//////////////////////
////////////////////// 
//////////////////////输入：n = 11
//////////////////////输出：false
//////////////////////解释：11 的二进制表示是：1011. 
//////////////////////
////////////////////// 
//////////////////////
////////////////////// 提示： 
//////////////////////
////////////////////// 
////////////////////// 1 <= n <= 2³¹ - 1 
////////////////////// 
////////////////////// Related Topics 位运算 👍 162 👎 0
////////////////////
//////////////////
////////////////
//////////////
////////////
//////////
////////
//////
////
//

  
package com.deemo.leetcode.editor.cn;
public class BinaryNumberWithAlternatingBits{
    public static void main(String[] args) {
        Solution solution = new BinaryNumberWithAlternatingBits().new Solution();
        System.out.println(solution.hasAlternatingBits(170));
    }
    //leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public boolean hasAlternatingBits(int n) {
        // 二进制题，考虑位运算
        // 交替字符串，错位相或，如果是交替数，将得到全1
        int x = n ^ (n >> 1);
        // 然后判断是否是全1
        return (x & (x + 1)) == 0;

        // 不能直接于，例如4，当且仅当中间存在连续1时才会满足此
        // return (n & (n >> 1)) == 0;
    }
}
//leetcode submit region end(Prohibit modification and deletion)

}